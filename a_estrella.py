# -*- coding: utf-8 -*-
"""A_estrella.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xzHZAJUTTn_QSrpYJ5OFYy7rptpJovUr
"""

import math

'''''
La Clase nodo consta de su posición (x, y),  
el valor de g, de h y quien es su nodo padre
'''''
class Node:
    def __init__(self, x, y, g, h, parent):
        self.x = x
        self.y = y
        self.g = g
        self.h = h
        self.parent = parent
        
    def __lt__(self, other):
        return self.g + self.h < other.g + other.h
        
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

#   La heurística que se usa en este problema
#   es la distancia euclidiana
def euclidean_distance(x1, y1, x2, y2):
    return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)

#   Algoritmo A*: recibe como parámetros el "tablero" problema que queremos resolver (board),
#   así como la posición inicio (start), y la posición objetivo (end)
def A_star(board, start, end):
    start_node = Node(start[0], start[1], 0, euclidean_distance(start[0], start[1], end[0], end[1]), None)
    end_node = Node(end[0], end[1], 0, 0, None)
    
    #   Inicializamos la lista abierta y la lista cerrada
    #   ponemos el nodo inicial en la lista abierta
    open_list = [start_node]
    closed_list = []
    
    #   Mientras la lista abierta no esté vacía...
    while len(open_list) > 0:
        
        #   ... Buscamos el nodo con el valor f mas pequeño
        #   en la lista abierta, será nuestro nodo actual
        current_node = min(open_list, key=lambda x: x.g + x.h)

        #   Quitamos al nodo actual de la lista abierta y 
        #   lo añadimos a la lista cerrada  
        open_list.remove(current_node)
        closed_list.append(current_node)
        

        #Si el nodo actual es el nodo destino, detenemos la búsqueda
        if current_node == end_node:
            path = []
            node = current_node
            while node is not None:
                path.append((node.x, node.y))
                node = node.parent
            return path[::-1]
        
        #   Generamos los vecinos de nuestro nodo:
        neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for dx, dy in neighbors:
            x = current_node.x + dx
            y = current_node.y + dy
            
            #   Evaluamos si nos encontramos en los límites del tablero
            if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]):
                continue

            #   Evaluamos si hay algún obstáculo  
            if board[x][y] == "X":
                continue

            #   Calculamos g y h del nuevo nodo    
            new_g = current_node.g + euclidean_distance(current_node.x, current_node.y, x, y)
            new_node = Node(x, y, new_g, euclidean_distance(x, y, end_node.x, end_node.y), current_node)
            
            #   Si hay un nodo con la misma posición en la lista cerrada,
            #   pasamos a la siguiente iteración
            if any(node == new_node for node in closed_list):
                continue
            
            #   Si hay un nodo con la misma posición en la lista abierta,
            #   actualizamos el nodo actual, y evaluamos si el sucesor
            #   tiene un valor de g menor al actual, de ser así, pasamos
            #   a la siguiente iteración
            if any(node == new_node for node in open_list):
                node = next(node for node in open_list if node == new_node)
                if new_g < node.g:
                    node.g = new_g
                    node.parent = current_node
                continue
            
            #   Si no se cumplen las anteriores evaluaciones, añadimos el nodo
            #   sucesor a la lista abierta
            open_list.append(new_node)
            
    return None

#   Creamos el tablero que deseamos resolver
board= [[' ', ' ', ' ', ' ', ' '],
        [' ', 'S', ' ', ' ', ' '],
        [' ', 'X', 'X', ' ', ' '],
        [' ', ' ', 'X', ' ', ' '],
        [' ', 'X', 'X', 'X', ' '],
        [' ', ' ', ' ', 'G', ' '],
        [' ', ' ', ' ', ' ', ' ']]

#indicamos las posiciones de inicio y fin
start = (1, 1)
end = (5, 3)

#guardamos el camino en la variable path
path = A_star(board, start, end)

#   Imprimimos el camnio como 8s 
#   Los obstáculos como 0s
#   y el resto de casillas como 1s
if path is not None:
    for i in range(len(board)):
        for j in range(len(board[0])):
            if (i, j) in path:
                print(8, end=" ")
            elif board[i][j] == "X":
                print(0, end=" ")
            else:
                print(1, end=" ")
        print()
else:
    print("No path found")