# -*- coding: utf-8 -*-
"""P6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wp7Hr7uVsB1IkQPEwVZ_GUyUiVwIbZTN
"""

#En esta sección se importan las librerías numpy.
#se utilizan para el manejo de arrays/matrices.
import numpy as np

#Definimos matriz P de tamaño 7x10.
#Dígitos del 0 al 9.
P = np.matrix( [[1,1,1,1,1,1,0], #0
                [0,1,1,0,0,0,0], #1
                [1,1,0,1,1,0,1], #2
                [1,1,1,1,0,0,1], #3
                [0,1,1,0,0,1,1], #4
                [1,0,1,1,0,1,1], #5
                [1,0,1,1,1,1,1], #6
                [1,1,1,0,0,0,0], #7
                [1,1,1,1,1,1,1], #8
                [1,1,1,1,0,1,1]]) #9

#Transpone la matriz P para cada fila represente una característica del patrón
P = P.T

#Condicionales
#1 Numeros pares
#t_pares = np.matrix([1,0,1,0,1,0,1,0,1,0])
#t = t_pares.T

#2 Numeros Mayores a 5
#t_mayora5 = np.matrix([0,0,0,0,0,0,1,1,1,1])

#3 Numeros Primos
t_primos = np.matrix([0,0,1,1,0,1,0,1,0,0])

#Definimos dos matrices W y b que representan los pesos y sesgos de la red neuronal.
#Los valores iniciales de W y b se generan aleatoriamente utilizando la función np.random.rand() de NumPy.
#Devuelve una matriz de números aleatorios entre 0 y 1. 
#Se multiplica por 2 y se resta 1 para generar valores entre -1 y 1.

W = np.matrix(2*np.random.rand(1,7) - 1)
b = np.matrix(2*np.random.rand(1,1) - 1)

#Se crea una matriz de errores inicializada con ceros.
e = np.matrix(np.zeros(10))
e = e.T

#Entrenamiento de la red
#El primer for sirve para iterar sobre N número de épocas de entrenamiento.
#El segundo para iterar sobre cada ejemplo de entrenamiento en el conjunto de datos.
#Se calcula el error entre la salida esperada (t[q]) y la salida real de la red (np.heaviside(W * P[:, q] + b, 1)). 
#Devuelve 0 si el valor es negativo, 1 si el valor es cero y 1 si el valor es positivo
#El error se utiliza para ajustar los pesos y sesgos de la red mediante la regla de aprendizaje de Hebb.

for epocas in range(100):
    for q in range(10):
        e[q] = t[q] - np.heaviside(W *  P[:, q] + b, 1)
        W = W + e[q].T * P[:,q].T
        b = b + e[q]

#Impresiones
#Vector de Errores (e)
print("e = ")
print(e.T)

#Pesos (W) 
print("W = ")
print(W)

#Sesgo (b)
print("b = ")
print(b)